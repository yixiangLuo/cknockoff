% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cknockoff.R
\name{cknockoff}
\alias{cknockoff}
\title{The cKnockoff procedure}
\usage{
cknockoff(
  X,
  y,
  knockoffs = knockoff::create.fixed,
  statistic = stat.glmnet_coefdiff_lm,
  alpha = 0.05,
  kappa = 1,
  n_cores = 1,
  knockoff.type = c("fixed", "model"),
  prelim_result = NULL,
  X.pack = NULL
)
}
\arguments{
\item{X}{n-by-p matrix or data frame of predictors.}

\item{y}{response vector of length n.}

\item{knockoffs}{knockoffs method used to construct the knockoff matrix for X.
It should be a function taking a n-by-p matrix as input and returning a n-by-p
matrix of knockoff variables.
It is the same as the \code{knockoffs} parameter in \href{knockoff}{https://cran.r-project.org/web/packages/knockoff/}\code{::knockoff.filter}.
By default, \code{knockoff::create.fixed} is used.}

\item{statistic}{the knockoff W-statistics used to assess variable importance.
Any statistic function in \href{knockoff}{https://cran.r-project.org/web/packages/knockoff/}
can be passed via this parameter.
But please be aware of efficiency issue as this function will be called
repeatedly in cknockoff. We suggest use the statistic functions supplied by
our package.
By default, a lasso statistic from our package is used.}

\item{alpha}{target false discovery rate (default: 0.05).}

\item{kappa}{a real number between 0 and 1 controlling how should we hybridize
knockoff with Bonferroni in cKnockoff.
By default, kappa = 1, meaning we don't hybridize and use knockoff only.}

\item{n_cores}{the number of cores used in computing cKnockoff in parallel.
package \code{doParallel} is required if \code{n_cores} > 1.
Otherwise it's computed sequentially.}

\item{knockoff.type}{implies whether fixed-X or model-X knockoff is used.
Currently only supports fixed-X knockoff.
As a result, the parameter \code{knockoffs} has to be those for fixed-X.}

\item{prelim_result}{either a \code{knockoff.result} object returned by
\code{knockoff::knockoff.filter} or a \code{cknockoff.result} object returned
by \code{cknockoff}.
cknockoff can read the information from the knockoff result or previous
cknockoff result and make possibly more rejections under the same FDR control.
When supplied, all other parameters are not needed.}

\item{X.pack}{An object of class "cknockoff.X.pack" returned by \code{process_X}.
This is used only for simulations studies, where cknockoff is applied many
times to the same fixed X, to accelerate computation. General users should
ignore it and leave it as default = NULL.}
}
\value{
An object of class "cknockoff.result". This object is a list similar
to the "knockoff.result" object, containing essentially the same information:
\item{X}{matrix of original variables (scaled and possibly augmented)}
\item{Xk}{matrix of knockoff variables (cooresponding the the returned X)}
\item{y}{response vector (possibly augmented)}
\item{kn.statistic}{the knockoff W statistics}
\item{selected}{named vector of selected variables}
\item{record}{a list recording information used to assist computing from
"prelim_result". Users should not worry or care about it.}
}
\description{
This function apply the cKnockoff procedure to the data under linear model,
selecting important features with FDR control. It has power dominating knockoff
via conditional calibration.
}
\details{
#' The parameter \code{kappa} controls how Knockoff and Bonferroni is hybridized
in cKnockoff.
As kappa get closer to 1, cKnockoff behave more like Knockoff:
relying on the knockoff W statistics heavier.
While as kappa get closer to 0, cKnockoff behave more like Bonferroni:
relying on the p-values heavier.
In particular, cKnockoff(alpha; kappa) almost surely dominates
Knockoff(fdr = kappa \* alpha) union Bonferroni(fdr = (1-kappa) \* alpha).

If parameter "prelim_result" is supplied, all the other parameters except
"n_cores" will be overwritten by the information extracted from it.

If a \code{knockoff.result} object is supplied, cknockoff will return possibly
more selections on the same problem with the same FDR control.
To use, the function call of \code{knockoff::knockoff.filter} that generates
such \code{knockoff.result} object should specify parameters \code{statistic}
and \code{fdr} explicitly (rather than relying on the default).

It's possible to even make more rejections based on a \code{cknockoff.result}
object. This is because cknockoff will only explore those promising features
and discards the others, say those with large p-values.
Calling cknockoff() on a \code{cknockoff.result} object would further
explore some most promising ones among the discarded features and (rarely)
possibly make several more rejections. You can do this recursively and FDR is
proved to be controlled whenever you decide to stop.
The computational time of each call should be similar.
}
\examples{
p <- 100; n <- 300; k <- 15
X <- matrix(rnorm(n*p), n)
nonzero <- sample(p, k)
beta <- 3.5 * (1:p \%in\% nonzero)
y = X \%*\% beta + rnorm(n)

# Basic usage
result <- cknockoff(X, y, alpha = 0.05, n_cores = 1)
print(result$selected)

# improve knockoff and previous cknockoff result
library("knockoff")
kn.result <- knockoff.filter(X, y,
                             knockoffs = create.fixed,
                             statistic = stat.glmnet_coefdiff_lm,
                             fdr = 0.05)
print(kn.result$selected)
result <- cknockoff(prelim_result = kn.result, n_cores = 2)
print(result$selected)
result <- cknockoff(prelim_result = result)
print(result$selected)
}
\references{

}
